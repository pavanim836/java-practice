//Scanner.nextLine() is used after integer input to consume the leftover newline character (\n) that remains in the input buffer after methods like nextInt().
Step-by-step:
->nextInt() reads only the number 20
->It does NOT consume the Enter key
-->The newline (\n) remains in the input buffer
-->nextLine() reads that leftover newline
-->Result: name = "" (empty string) 

<---------------------------answer----------------------------------->
import java.util.Scanner;

public class Solution {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int i = scan.nextInt();
        double d = scan.nextDouble();
        scan.nextLine();
        String s = scan.nextLine();

        // Write your code here.

        System.out.println("String: " + s);
        System.out.println("Double: " + d);
        System.out.println("Int: " + i);
    }
}

<-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//converting int to string
int num = 123;
String str = String.valueOf(num);
                or
int num = 123;
String str = Integer.toString(num);

//converting double to int
double d = 10.75;
int i = (int) d;   // Output: 10

//converting double to string
double d = 5.5;
String s = String.valueOf(d);

//converting boolean to string
boolean b = true;
String s = String.valueOf(b);

//converting string to num
String s = "123";
int a = Integer.parseInt(s);

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//Java has 8 primitive data types; char, boolean, byte, short, int, long, float, and double. For this exercise, we'll work with the primitives used to hold integer values (byte, short, int, and long):

//A byte is an 8-bit signed integer.
//A short is a 16-bit signed integer.
//An int is a 32-bit signed integer.
//A long is a 64-bit signed integer.
//Given an input integer, you must determine which primitive data types are capable of properly storing that input.

//<------------------------answer-------------------------->

import java.util.*;
import java.io.*;

class Solution{
    public static void main(String []argh)
    {



        Scanner sc = new Scanner(System.in);
        int t=sc.nextInt();

        for(int i=0;i<t;i++)
        {

            try
            {
                long x=sc.nextLong();
                System.out.println(x+" can be fitted in:");
                if(x>=-128 && x<=127)System.out.println("* byte");
                if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
                    System.out.println("* short");
                if (x >= Integer.MIN_VALUE && x <= Integer.MAX_VALUE)
                    System.out.println("* int");
                if (x >= Long.MIN_VALUE && x <= Long.MAX_VALUE)
                    System.out.println("* long");
            }
            catch(Exception e)
            {
                System.out.println(sc.next()+" can't be fitted anywhere.");
            }

        }
    }
}

<------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//The challenge here is to read  lines of input until you reach EOF, then number and print all  lines of content.
//Why EOF (hasNextLine()) is used
//Because input size is unknown

//In EOF-based problems, you do not know how many lines the input will have.

//❌ You cannot use a for loop

//❌ You cannot fix the number of iterations

//✅ You must read until input ends

//EOF solves this.

//<----------------------answer------------------------>

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
import java.util.Scanner;

public class Solution {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int linenumber=1;
        while(sc.hasNextLine()){
            String line=sc.nextLine();
            System.out.println(linenumber+" "+line);
            linenumber++;
        }
    }
}

<-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//Static initialization blocks are executed when the class is loaded, and you can initialize static variables in those blocks.
//It is primarily used to initialize static variables that require complex logic or computation.
//Declared using the static { } keyword.
//Executes before the main() method.
//Runs only once per class, regardless of how many objects are created.
//Used only for static members.
//Syntax    :class Example {
                     static {
                         // static initialization code
                     }
            }


//There are two lines of input. The first line contains : the breadth of the parallelogram. The next line contains : the height of the parallelogram.
//If both values are greater than zero, then the main method must output the area of the parallelogram. Otherwise, print "java.lang.Exception: Breadth and height must be positive" without quotes.

<------------------------------ANSWER--------------------------->
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    static int H;
    static int B;
    static boolean flag;
    static{
        Scanner sc=new Scanner(System.in);
        B=sc.nextInt();
        H=sc.nextInt();
        if(B>0 && H>0){
            flag=true;
        }
        else{
            System.out.println("java.lang.Exception: Breadth and height must be positive");
            flag=false;
        } 
     }
public static void main(String[] args){
		if(flag){
			int area=B*H;
			System.out.print(area);
		}	
	}
}

<------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
Given a double-precision number, , denoting an amount of money, 
use the NumberFormat class' getCurrencyInstance method to convert  into the US, Indian, Chinese, and French currency formats.
-->NumberFormat.getCurrencyInstance()
   This method:
   Converts a number into currency format
-->us.format(payment)
  Adds currency symbol
  Adds commas
  Rounds to 2 decimals
  Uses local symbols, commas, and decimals

<------------------------------answer---------------------------------------------->
import java.util.*;
import java.text.*;
import java.text.NumberFormat;
import java.util.Locale;

public class Solution {
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double payment = scanner.nextDouble();
        scanner.close();
        
        NumberFormat us=NumberFormat.getCurrencyInstance(Locale.US);
        NumberFormat india=NumberFormat.getCurrencyInstance(new Locale("en","IN"));
        NumberFormat china=NumberFormat.getCurrencyInstance(Locale.CHINA);
        NumberFormat france=NumberFormat.getCurrencyInstance(Locale.FRANCE);
        System.out.println("US: " + us.format(payment));
        System.out.println("India: " + india.format(payment));
        System.out.println("China: " + china.format(payment));
        System.out.println("France: " + france.format(payment));
    }
}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
//to find the day of the gievn date

<------------------------answer------------------------------>

import java.time.LocalDate;
import java.time.DayOfWeek;

public class DayFromDate {
    public static void main(String[] args) {

        int day = 30;
        int month = 12;
        int year = 2025;

        LocalDate date = LocalDate.of(year, month, day);
        DayOfWeek dayOfWeek = date.getDayOfWeek();

        System.out.println("Day is: " + dayOfWeek);
    }
}
