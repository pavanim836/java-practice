//Scanner.nextLine() is used after integer input to consume the leftover newline character (\n) that remains in the input buffer after methods like nextInt().
Step-by-step:
->nextInt() reads only the number 20
->It does NOT consume the Enter key
-->The newline (\n) remains in the input buffer
-->nextLine() reads that leftover newline
-->Result: name = "" (empty string) 

<---------------------------answer----------------------------------->
import java.util.Scanner;

public class Solution {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int i = scan.nextInt();
        double d = scan.nextDouble();
        scan.nextLine();
        String s = scan.nextLine();

        // Write your code here.

        System.out.println("String: " + s);
        System.out.println("Double: " + d);
        System.out.println("Int: " + i);
    }
}

<-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//converting int to string
int num = 123;
String str = String.valueOf(num);
                or
int num = 123;
String str = Integer.toString(num);

//converting double to int
double d = 10.75;
int i = (int) d;   // Output: 10

//converting double to string
double d = 5.5;
String s = String.valueOf(d);

//converting boolean to string
boolean b = true;
String s = String.valueOf(b);

//converting string to num
String s = "123";
int a = Integer.parseInt(s);

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//Java has 8 primitive data types; char, boolean, byte, short, int, long, float, and double. For this exercise, we'll work with the primitives used to hold integer values (byte, short, int, and long):

//A byte is an 8-bit signed integer.
//A short is a 16-bit signed integer.
//An int is a 32-bit signed integer.
//A long is a 64-bit signed integer.
//Given an input integer, you must determine which primitive data types are capable of properly storing that input.

//<------------------------answer-------------------------->

import java.util.*;
import java.io.*;

class Solution{
    public static void main(String []argh)
    {



        Scanner sc = new Scanner(System.in);
        int t=sc.nextInt();

        for(int i=0;i<t;i++)
        {

            try
            {
                long x=sc.nextLong();
                System.out.println(x+" can be fitted in:");
                if(x>=-128 && x<=127)System.out.println("* byte");
                if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
                    System.out.println("* short");
                if (x >= Integer.MIN_VALUE && x <= Integer.MAX_VALUE)
                    System.out.println("* int");
                if (x >= Long.MIN_VALUE && x <= Long.MAX_VALUE)
                    System.out.println("* long");
            }
            catch(Exception e)
            {
                System.out.println(sc.next()+" can't be fitted anywhere.");
            }

        }
    }
}

<------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//The challenge here is to read  lines of input until you reach EOF, then number and print all  lines of content.
//Why EOF (hasNextLine()) is used
//Because input size is unknown

//In EOF-based problems, you do not know how many lines the input will have.

//❌ You cannot use a for loop

//❌ You cannot fix the number of iterations

//✅ You must read until input ends

//EOF solves this.

//<----------------------answer------------------------>

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
import java.util.Scanner;

public class Solution {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int linenumber=1;
        while(sc.hasNextLine()){
            String line=sc.nextLine();
            System.out.println(linenumber+" "+line);
            linenumber++;
        }
    }
}

<-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

//Static initialization blocks are executed when the class is loaded, and you can initialize static variables in those blocks.
//It is primarily used to initialize static variables that require complex logic or computation.
//Declared using the static { } keyword.
//Executes before the main() method.
//Runs only once per class, regardless of how many objects are created.
//Used only for static members.
//Syntax    :class Example {
                     static {
                         // static initialization code
                     }
            }


//There are two lines of input. The first line contains : the breadth of the parallelogram. The next line contains : the height of the parallelogram.
//If both values are greater than zero, then the main method must output the area of the parallelogram. Otherwise, print "java.lang.Exception: Breadth and height must be positive" without quotes.

<------------------------------ANSWER--------------------------->
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    static int H;
    static int B;
    static boolean flag;
    static{
        Scanner sc=new Scanner(System.in);
        B=sc.nextInt();
        H=sc.nextInt();
        if(B>0 && H>0){
            flag=true;
        }
        else{
            System.out.println("java.lang.Exception: Breadth and height must be positive");
            flag=false;
        } 
     }
public static void main(String[] args){
		if(flag){
			int area=B*H;
			System.out.print(area);
		}	
	}
}

<------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
Given a double-precision number, , denoting an amount of money, 
use the NumberFormat class' getCurrencyInstance method to convert  into the US, Indian, Chinese, and French currency formats.
-->NumberFormat.getCurrencyInstance()
   This method:
   Converts a number into currency format
-->us.format(payment)
  Adds currency symbol
  Adds commas
  Rounds to 2 decimals
  Uses local symbols, commas, and decimals

<------------------------------answer---------------------------------------------->
import java.util.*;
import java.text.*;
import java.text.NumberFormat;
import java.util.Locale;

public class Solution {
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double payment = scanner.nextDouble();
        scanner.close();
        
        NumberFormat us=NumberFormat.getCurrencyInstance(Locale.US);
        NumberFormat india=NumberFormat.getCurrencyInstance(new Locale("en","IN"));
        NumberFormat china=NumberFormat.getCurrencyInstance(Locale.CHINA);
        NumberFormat france=NumberFormat.getCurrencyInstance(Locale.FRANCE);
        System.out.println("US: " + us.format(payment));
        System.out.println("India: " + india.format(payment));
        System.out.println("China: " + china.format(payment));
        System.out.println("France: " + france.format(payment));
    }
}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
//to find the day of the gievn date

<------------------------answer------------------------------>

import java.time.LocalDate;
import java.time.DayOfWeek;

public class DayFromDate {
    public static void main(String[] args) {

        int day = 30;
        int month = 12;
        int year = 2025;

        LocalDate date = LocalDate.of(year, month, day);
        DayOfWeek dayOfWeek = date.getDayOfWeek();

        System.out.println("Day is: " + dayOfWeek);
    }
}

<--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
Given two strings of lowercase English letters,  and , perform the following operations:

Sum the lengths of  and .
Determine if  is lexicographically larger than  (i.e.: does  come before  in the dictionary?).
Capitalize the first letter in  and  and print them on a single line, separated by a space.
<-----------------------answer---------------------------------->
import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) {
        
        Scanner sc=new Scanner(System.in);
        String A=sc.next();
        String B=sc.next();
        int totsum=A.length()+B.length();
        System.out.println(totsum);
        if(A.compareTo(B)>0){                //compares to strings,which is greater?
            System.out.println("Yes");
        }
        else{
            System.out.println("No");
        }
        String capA = A.substring(0, 1).toUpperCase() + A.substring(1);
        String capB = B.substring(0, 1).toUpperCase() + B.substring(1);

        System.out.println(capA + " " + capB);
    }
}

//A.substring(0, 1).toUpperCase()----->extracts the characters between 0,1 i.e.,0th character. then converts it to uppercase
//A.substring(1)----------->then adds the remaining characters

<------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------>
Given a string, , and an integer, , complete the function so that it finds the lexicographically smallest and largest substrings of length .
<---------------------------------answer------------------------------------>
import java.util.Scanner;

public class Solution {

    public static String getSmallestAndLargest(String s, int k) {
          String smallest = s.substring(0, k);
          String largest = s.substring(0, k);
        
        
    for (int i = 1; i <= s.length() - k; i++) {
        String current = s.substring(i, i + k);

        if (current.compareTo(smallest) < 0) {
            smallest = current;
        }

        if (current.compareTo(largest) > 0) {
            largest = current;
        }
    }

        return smallest + "\n" + largest;
    }


    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String s = scan.next();
        int k = scan.nextInt();
        scan.close();
      
        System.out.println(getSmallestAndLargest(s, k));
    }
}
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
Check if given string is palindrome or not
<---------------------------answer-------------------------------------------->
import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) {
        
        Scanner sc=new Scanner(System.in);
        String A=sc.next();
        String B="";
        // StringBuilder b=new StringBuilder(A);
        // b.reverse();
        // String B=b.toString();
        for(int i=A.length()-1;i>=0;i--)
        {
            B=B+A.charAt(i);
        }
        if(A.equals(B)){
            System.out.println("Yes");
        }
        else{
            System.out.println("No");
        }
    }
}
<-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
//Two strings,  and , are called anagrams if they contain all the same characters in the same frequencies.
//For this challenge, the test is not case-sensitive. For example, the anagrams of CAT are CAT, ACT, tac, TCA, aTC, and CtA.
<-------------------------------------------answer------------------------------------------------>
import java.util.Scanner;

public class Solution {

    static boolean isAnagram(String a, String b) {
       
    if (a.length() != b.length()) {
        return false;
    }

    a = a.toLowerCase();
    b = b.toLowerCase();

    int[] count = new int[26];

    for (int i = 0; i < a.length(); i++) {
        count[a.charAt(i) - 'a']++;
        count[b.charAt(i) - 'a']--;
    }

    for (int c : count) {
        if (c != 0) {
            return false;
        }
    }

    return true;
}
    public static void main(String[] args) {
    
        Scanner scan = new Scanner(System.in);
        String a = scan.next();
        String b = scan.next();
        scan.close();
        boolean ret = isAnagram(a, b);
        System.out.println( (ret) ? "Anagrams" : "Not Anagrams" );
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<OR>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
import java.util.Arrays;

public class Solution {

    static boolean isAnagram(String a, String b) {

        a = a.toLowerCase();
        b = b.toLowerCase();

        if (a.length() != b.length()) {
            return false;
        }

        char[] arr1 = a.toCharArray();
        char[] arr2 = b.toCharArray();

        Arrays.sort(arr1);
        Arrays.sort(arr2);

        return Arrays.equals(arr1, arr2);
    }

    public static void main(String[] args) {
        System.out.println(isAnagram("CAT", "tac")); // true
    }
}
<------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
Given a string, , matching the regular expression [A-Za-z !,?._'@]+, split the string into tokens.
We define a token to be one or more consecutive English alphabetic letters. Then, print the number of tokens, followed by each token on a new line.
<-------------------------------answer------------------------------------------->
import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String s = scan.nextLine().trim();  //.trim()Removes leading and trailing delimiters, Prevents empty tokens at the start or end.
        if(s.isEmpty()){
            System.out.println(0);
            return;
        }
        String regex = "[^A-Za-z]+";  //splits everything other than letters  -->[+]it is used because if there are more than one seperators[spaces,punctuations] 
                                      //it considers it as one seperator.
        String[] arr = s.split(regex);
        System.out.println(arr.length);
        
        for (String str : arr) {
            System.out.println(str);
        }
        scan.close();
    }
}

<--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
Using Regex, we can easily match or search for patterns in a text. Before searching for a pattern, we have to specify one using some well-defined syntax.
In this problem, you are given a pattern. You have to check whether the syntax of the given pattern is valid.
Note: In this problem, a regex is only valid if you can compile it using the Pattern.compile method.
<---------------------------------answwer---------------------------------->
import java.util.Scanner;
import java.util.regex.*;

public class Solution
{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        sc.nextLine(); 

        for (int i = 0; i < t; i++) {
            String regex = sc.nextLine();
///exception handling///
            try {
                Pattern.compile(regex);
                System.out.println("Valid");
            } catch (Exception e) {
                System.out.println("Invalid");
            }
        }
	}
}
Pattern.compile(regex):
-->Java internally checks regex grammar
-->Examples of invalid syntax:
-->Unclosed brackets [abc
-->Wrong quantifiers a++
-->Misplaced operators *abc
When syntax is wrong → exception thrown

<------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------>

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution{
	public static void main(String[] args){
		
		Scanner in = new Scanner(System.in);
		int testCases = Integer.parseInt(in.nextLine());
		while(testCases>0){
			String line = in.nextLine();
			
          	Pattern pattern = Pattern.compile("<(.+)>([^<]+)</\\1>");
			Matcher matcher = pattern.matcher(line);

            boolean found = false;

            while (matcher.find()) {
                System.out.println(matcher.group(2));  ---->group(2) bcz content is in secoond position
                found = true;
            }

            if (!found) {
                System.out.println("None");
            }
			testCases--;
		}
	}
}

Pattern  → defines rule
   ↓
Matcher → applies rule to string
   ↓
find()  → searches next match
   ↓
group() → extracts matched parts

(1) <(.+)> ----> <h1>
(2) ([^<]+) ---> content
(3) </\\1> ----> </h1>    [\1 ensures opening and closing tags are identical]
  
